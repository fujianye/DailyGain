
1、跳跃表



2、压缩链表


Redis中，不同的数据类型广泛地应用了压缩列表编码，整理如下表：

[image]https://github.com/fujianye/DailyGain/blob/master/images/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png

Redis中数据结构类型与压缩列表的应用

上表总结了压缩列表编码在Redis不同的数据类型中的应用，Redis一共支持五种数据结构类型，其中有三种数据结构在一定条件下会应用压缩列表

Redis对于每种数据结构、无论是列表、哈希表还是有序集合，
在决定是否应用压缩列表作为当前数据结构类型的底层编码的时候都会依赖一个开关和一个阈值，
开关用来决定我们是否要启用压缩列表编码，
阈值总的来说通常指当前结构存储的key数量有没有达到一个数值（条件），或者是value值长度有没有达到一定的长度（条件）。
任何策略都有其应用场景，不同场景应用不同策略。
为什么当前结构存储的数据条目达到一定数值使用压缩列表就不好？
压缩列表的新增、删除的操作平均时间复杂度为O(N)，随着N的增大，时间必然会增加，
他不像哈希表可以以O(1)的时间复杂度找到存取位置，然而在一定N内的时间复杂度我们可以容忍。
然而压缩列表利用巧妙的编码技术除了存储内容尽可能的减少不必要的内存开销，
将数据存储于连续的内存区域，这对于Redis本身来说是有意义的，因为Redis是一款内存数据库软件，想办法尽可能减少内存的开销是Redis设计者一定要考虑的事情。

3、双端链表
双端链表：
节点类保留下一节点的引用。链表类保留头节点、尾节点的引用，可以从尾节点插入，但只能从头节点删除；

双向链表：
节点类保留上一节点、下一节点的引用。链表类保留头节点、尾节点的引用，可以从尾节点插入删除；

Redis 列表使用两种数据结构作为底层实现：
双端链表
压缩列表
因为双端链表占用的内存比压缩列表要多， 所以当创建新的列表键时， 列表会优先考虑使用压缩列表作为底层实现， 
并且在有需要的时候， 才从压缩列表实现转换到双端链表实现。
