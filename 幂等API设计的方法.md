# 事例
某种商品A的当前库存量为100，那么对应的减库存 API 如果接收的是一个差值参数就不能称之为幂等。例如：如果我们设计这个减库存的 API 为 Consume(int delta)，其中 delta 参数表示期望发生的库存变化差量（如在提交订单时，需要库存减1，就调用“ Consume(1)”），这就是不幂等的 API，这个 API 请求如果由于网络等故障被反复送达的话，会导致库存多次被减1（假如该请求被重复送达3次，则此时商品A的库存量为97）。

# 幂等 API 实现方式通常有两种
## 1、基于 CAS（Compare And Swap）类的原子操作来实现
仍然看上面的例子，若将 API 变为：Consume(int from, int to)，其中 from 指定调用者认为的商品A当前库存量，to 则指定调用者期望此操作结束后商品A的新库存量。上例中库存减一应该写作：Consume(100, 99)。这样，Consume 在执行时会先原子（事务级，不是内存总线级）地比对当前库存是否为 100，只有在当前库存为 100 时，才将其调整为 99。这时即使此调用被重复送达，也不会产生上述副作用。其实广义上说，直接写 Consume(int to)，如：Consume(99) 也可以算是幂等操作了。但显而易见，这么写在分布式场景下仍然无法保证安全。具体就不必展开说了吧？
## 2、基于 REQUEST ID + 状态机。
调用者在每次发起新请求时提交一个全局唯一的请求ID，执行者以ACID事务的方式在成功处理了请求的同时记录每一个已被处理的请求ID。新消息到达时先查表，看该请求是否已被处理过，若是则忽略并返回错误，否则才继续处理。上面的例子相当于状态机只有两种（已处理、未处理）状态，对复杂的请求来说，执行方通常会同时记录该请求的ID及其相关状态信息，在新消息到达后，可根据对应请求的状态决定是否可继续执行相应处理。例如：支付订单可有已支付、待支付、已预授权、已结算、已退款、已取消等等多种状态，每种状态下可对其执行的操作是不同的。
