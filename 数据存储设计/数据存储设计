在线业务系统存储实践经验

Agenda

零、讨论范围（问题域）
在线业务是什么样子

在线业务是通过信息流跟踪人类世界的活动。
在线业务的特征：
1、多方参与的协作（交互）。参与方：各种角色的人、规则（弱智机器人，比如计价规则）、模型（智能机器人）（我们开发的大部分工作都是在做规则和模型,比如计价 一堆的if-else）
2、有一个交互模型。视图 和 主存储。

视图提供信息，供人工、规则、模型来决策，决策产生命令，命令执行产生信息，信息存储在主存储中。

什么是视图？什么是主存储？
视图提供信息，供人工、规则、模型做决策。视图数据来源于主存储。
主存储记录业务的所有信息。主存储作为命令执行的依据，决策命令该怎么执行。
主存储的解决的问题：
1）术语和流程向业务对齐，减少需求的沟通成本。
2）维护数据不破坏业务规则。
3）权威性，数据不能被参与方随意篡改
4）持久化，实现长时间跨度的业务流程
5）事后可追溯性

3、将一连串的交互叠加起来就是流程。


一、在线业务对存储的需求
“在线业务存储”问题分解（5个小问题）

      视图    <=====>         主存储

   哪个快？  如何靠谱同步？     存什么？
                             怎么存？
                           如何保证规则？


（一）主存储的模型选择（存什么？）

存储模型的选择，要解决下面几个问题：
1、术语和流程向业务对齐。
2、事后可追溯，考虑客服的需求，能够还原当时的情形。
如何建模？
1）实体对象为中心。比如学校的大作业，教学系统，班级、老师和学生，通过主键关联。但是丢失了很多协作方面的信息
2）单据为中心。单据的公共特征是有一个时间戳字段，
司机表 乘客表 订单表，通过订单将司机和乘客关联起来，通过订单的状态 来表现司机和乘客关系的变化，记录当前处于流程的哪个阶段。状态机仍然不够，还需要有一张表 order_process，每一次状态变更时，都记录变更日志，在什么时间什么情况下变更的状态。满足事后可追溯的需求，这就是事件为中心的模型。
3）事件为中心。“事件”是最细粒度最精确的建模。
假如不存“状态”，存“事件”。事件：乘客下订单、指派司机、司机到达、行程开始、行程结束、乘客付款、司机收款。

三种建模方式的选择。举例：存储“司机取消订单的次数，司机最后一次取消的时间”。
以实体对象为中心：司机表中增加2个字段 “取消次数”、“最后一次取消时间”作为司机的属性
以单据为中心：订单表的订单状态字段，状态为“司机已取消”
以事件为中心：订单事件表：一条订单已取消的记录。
没有最合适的建模方式，有可能会组合使用。
案例学习
比如订单系统，order表是单据，order_process是事件。
经验总结：
以单据为中心的设计，事件从单据状态变更衍生出来。
主要的动机是提供状态变更事件给客服查询
每个单据状态的变化都会产生一条记录插入到process表（或者log日志表）
事件表数据量数倍于单据表
事件表数据量大，mysql处理不过来，而且客服查询量也大，可以迁移到hbase

比如账户系统，
账户表是实体对象为中心，
交易表是单据为中心（交易表有时间戳、交易的状态，简单的状态机）
流水日志表是事件为中心。
经验总结：
以单据为中心的设计，实体对象状态的同步更新。
事件可以对商业流程进行非常好的精确跟踪，但是在目前的存储系统里支持的成本比较高，只有在可追溯性和业务规则破坏之后代价非常高的领域被使用。
（账户余额有“可追溯性”的诉求，而且假如账户规则被破坏，代价也非常高，所以账户要有事件表）

小结：
主存储的模型选择：
可以选择“实体对象”、“单据”或者“事件”作为主存储模型
实体对象丢失的信息最多，事件能够最精确地建模事实
现有的存储方案对于海量的“单据”、“事件”支持并不好，还要自己去处理“冷数据归档”、分库分表等事情。客观上造成了大家尽量选择以实体对象为中心进行建模。
（模型复杂度从低到高 redis key => 实体对象 => 单据 => 事件）

（二）主存储的物理介质(怎么存？)
怎么选择介质，是redis 还是 mysql ?
介质要解决下面几个问题：
1）权威性，数据不能被参与方随意篡改，可靠
2）持久化，实现长时间跨度的业务流程（未支付订单，下次打车时要有提醒，假如不能持久化，用户会疯掉）
数据库是唯一的选择吗？不是。如果仅仅是上下文的传递，使得流程可以从一个环节到另一个环节时，传递一些信息。可以使用cookie、APP端存储信息传递给下一个环节。APP端存储的话，脱离了服务的控制，会被篡改，可以通过加密的方式存储，比如token。大部分还是在服务端的数据库存储。

案例分析：
1、案例一：冒泡
客户端保存冒泡ID
服务端保存冒泡
发单需要带上冒泡ID，然后从redis里取出冒泡信息
满足了“权威性”，业务上不需要“持久化”，但是“不可追溯”
依赖把脉日志来补充，但是全量日志保存时间缓慢
存储：redis + public log + didi log
因为redis会过期或者丢失，对于没有多少业务价值的数据，“一次性”的数据，可以使用redis。假如冒泡有更多的业务价值，可以放在数据库存储。

2、案例二：订单状态脏读
MySQL分表粒度不够细，导致主库无法承担全部的读写流量，需要使用从库来分担
主从延迟造成写入的数据无法立即读到
大部分情况下MySQL仍然是最佳的主存储选择

3、案例三：调度费
“听说”mysql不好加字段：
预留扩展字段
MySQL保存json
或者把字段外挂到redis里

小结：
主存储的物理介质选择：
MySQL是大多数情况下主存储的默认介质
MySQL“被认为”无法处理高TPS的读写，部分是因为hash策略问题，部分是真的因为TPS比较高
使用redis等非持久存储做主存储，因为“分表感觉好麻烦”，“冷数据归档”，“没必要吧”，但是redis并不是为此场景设计的
MySQL“被认为”不好加字段，所以一些“临时”需求都用redis或者rockstable解决



（三）主存储的并发控制(如何保证规则？)
解决以下问题：
1）维护数据不破坏业务规则。

常用的解决方案：sql的where条件子句是规则、db事务。
db能保证一条sql的操作是原子的。

案例学习
1、案例一：订单状态
update order set status = new_status where status in (status_1,status_2);
利用数据库的单表事务
直接把业务规则写在sql里
2、案例二：账户余额
start transaction
  insert transaction_bill;
  update account set balance = balance + delta where balance > 0 and status = normal;
commit transaction
实体状态（account）解决主存储的规则判断问题（账户有余额并且不是冻结状态）
单据（transaction_bill）解决并发冲突问题，实现rpc幂等
利用数据库的多表事务同步更新两种状态的模型
直接把业务规则写在sql里
3、案例三：抢单系统的订单锁
两个独立的事务：
先抢redis锁
然后更新订单表
4、案例四：司机拒单封禁（计数器场景）
事件：司机拒单（作为幂等判断条件）
实体对象：司机的拒单次数（存储在redis里）
事件记录和实体对象更新要同步
依赖于进程执行不被中断
5、案例五：计价器存储
司机账单
   |
   |---乘客账单
   |
   |---乘客账单

多层次的业务结构体（行程中订单）以json的形式整体存储为一个key，避免MySQL关系模型的多表一致性问题
事务实现：利用lua脚本实现Compare and swap，也就是乐观锁
本质上是锁和业务存储二合一

小结
主存储的并发控制：
如果以单据或者事件为中心，方便rpc幂等，防重入
如果以实体对象为中心，方便写规则，但是自身很难幂等
余额表结构设计，通过多表事务同时维护事件（单据）和实体对象的一致性更新，实现两者的兼得
当主存储选择不当的时候，就得“独立加锁”来解决并发下的业务规则不被破坏的问题
（有实体对象无单据，不能实现重入幂等，比如打车金领取发放，后期紧急加了redis存储做幂等控制）
（有事件或者单据无实体对象，不能很好的控制规则，比如司机最近2天的账期，如果不在司机实体上存储入账金额，就要在事件表统计最近2天的入账金额）


（四）视图的索引选择（哪个快？）
视图：查看视图的时候以多个主存储里实时查询的结果的合并
司机历史订单列表页
 
              司机历史订单
              /  /  \  \
             /	/    \  \
        order  应付 接送机 判责

先从order里把历史订单拉出来，在内存里把订单ID列表组装起来分别取批量查询应付、接送机信息、判责结果信息，然后在内存里组装这些信息。（运行时合并）

物化视图：“运行时合并”在某些情况并不能满足查询速度的要求，数据从主存储里提前同步到索引中。
比如广告，广告是要把素材提前推到索引中，

数据库的创新发展历史
最开始的key-value ==> 关系型数据库(降低开发成本) ==> hbase等内存型数据库（检索速度）
发展是根据视图的需求决定的。

索引就是一个选择的问题
memcached：仅支持点查询
rockstable：为模型特征更新场景优化，支持更新部分列
Hbase：相比k-v多了时间范围查询
Lbs++：为坐标和时间戳场景优化，和hbase一样也是主键检索
Mysql索引：Hbase只能主键索引，mysql可以给多字段加索引，但是字段有序
Elasticsearch：多字段索引，而且可以无序
Mysql冗余字段：暴力扫描再快，也比不上提前计算（提前把索引计算出来，放在冗余字段做索引）

（如何靠谱同步？）
主存储  ===>  物化视图
       同步

索引同步方式一：MySQL索引
主表的改动，MySQL自动同步到索引里

索引同步方式二：数据层binlog同步
案例：分身系统

表记录 oid（index） pid did time
  || 以oid分库分表，需要pid的索引访问。根据binlog
  \/ 
表记录 oid  pid（index）did time

假设仍然是订单ID和乘客ID的两个维度，我们实现了分身系统，把所有的来自于主库的数据更新完之后，通过binlog复制到另外一个表里面去。逻辑是自动完成的，也就相当于在做创建表的时候，创建一个索引，在分库分表情况下创建一个主key，然后在索引Key的情况下，自动把数据复制到另外一张表里，在DBProxy往下查询时，自动识别，直接查询。
这对于工程师来说是很大的解放，一张表里两个索引一样可以工作，当然这个也是有限制的，但它至少解决了写两张表的问题。这是我们第一个基于MySQL binlog的尝试，解决了很多业务问题，整个代码复杂度大幅下降。

账户系统可以通过分身，导入到hbase，hbase中根据用户ID、时间范围作为索引，能够查询归档数据。

索引同步方式三：业务层双写
carpool 按用户ID建模的行程列表

   driverAPI 
    /   \
   /     \
 order   carpool
 双写很多时候不靠谱，异常case很多 。insert完order 和 carpool，还要额外select order 和 carpool，再double-check一次

 索引同步方式四：业务层read-through
典型的cache方式
先读缓存，缓存读不到 读db，然后更新缓存
这是业务最喜欢，用的最多的视图同步方式。
缺点是：当缓存全部失效时，db要能抗住所有的请求。


小结
视图的索引选择：
从mysql 到elasticsearch 总有一款适合你
双写是最糟糕的模式，很容易产生视图数据不一致
业务层read-through的最大特点是“不求人”，但场景受限而且增加了业务代码的复杂度
基于主存储日志（比如binlog）的同步方式，可以避免污染业务逻辑代码，同步逻辑可以更健壮，是更长远的解决方案



二、业务流程
业务流程就是分布式事务，分布式事务就是业务流程。

不追求Raft Paxos
不追求让存储来保证分布式事务

四种分布式事务场景：
1、先做附属操作，后做事务：比如order三张表，最后写base
2、先做事务，后做附属操作：order完成，发短信消息
3、多个事务操作，有回滚关系：转账涉及2个余额账户
4、多个事务操作，有回滚关系，且流程中牵涉人工步骤：微信支付

理论上已经有完备的解决方案：
1）事务消息：保证要给rpc操作能跑完，不然一直重试
   * 1 先做附属操作，后做事务：比如order三张表，最后写base
   * 2 先做事务，后做附属操作：order完成，发短信消息
比如把接口调用挂在bridgeQ中，rpc1 rpc2 rpc3...全部执行完，撤销事务消息；如果执行的rpcn，中断了，bridgeQ会不停的去重试接口调用，甚至报警
2） 事务消息 + Saga pattern：每个操作提供一个逆操作，失败时按做过的操作记录回滚
   * 3 多个事务操作，有回滚关系：转账涉及2个余额账户
   * 4 多个事务操作，有回滚关系，且流程中牵涉人工步骤：微信支付
Saga pattern：所做的每一步操作都要记录下来，假如rpcn执行失败，rpc1到rpc(n-1)都要回滚。如果不涉及人工审批或者人工操作，执行过的rpc，可以记录在内存中，否则就要持久化保存。

业务是可以容忍“时间差”“重试”的，所以不必做到实时一致性，最终一致性就够用了


三、理想的在线业务存储
三种“同步”：
1、event 和 state 同步，比如account 和 transaction_bill
2、主存储和物化视图的同步
3、一个操作更新多个存储，也是一种“同步”

分层解决各自的问题，如下：
  场景服务（系分市场）
  业务流程层（能够扩展和定制）
  在线业务存储层（解决前两种“同步”，可以实现类似于文档数据库的结构，对上提供自助化服务。存储层不用做业务，）


理想的在线业务存储系统
问题一：需求是视图还是主存储？
问题二：数据是如何被流程使用的
问题三：每种数据的存储选对了吗？


