分布式事务的实现方式有很多种，最具有代表性的是由Oracle Tuxedo系统提出的XA分布式事务协议。
XA协议包括两阶段提交（2PC）和三阶段提交（3PC）两种实现。2PC、3PC都是在跨库的DB层面。
1、2PC 是XA协议的一种。
第一阶段：请求/表决阶段。
就是在分布式事务的发起方在向分布式事务协调者（Coordinator）发送请求时，
Coordinator首先会分别向参与者（Partcipant）节点A、参与者（Partcipant）节点B分别发送事务预处理请求，称之为Prepare，有些资料也叫"Vote Request"。
第二阶段：提交/执行阶段（正常流程）
如果所有参与者节点都向协调者报告说“我这边可以处理”，那么此时协调者就会向所有参与者节点发送“全局提交确认通知（global_commit）”，
即你们都可以进行本地事务提交了，此时参与者节点就会完成自身本地数据库事务的提交，并最终将提交结果回复“ack”消息给Coordinator，
然后Coordinator就会向调用方返回分布式事务处理完成的结果。
第二阶段：提交/执行阶段（异常流程）
相反，在第二阶段除了所有的参与者节点都反馈“我这边可以处理了”的情况外，也会有节点反馈说“我这边不能处理”的情况发生，
此时参与者节点就会向协调者节点反馈“Vote_Abort”的消息。
此时分布式事务协调者节点就会向所有的参与者节点发起事务回滚的消息（“global_rollback”），
此时各个参与者节点就会回滚本地事务，释放资源，并且向协调者节点发送“ack”确认消息，
协调者节点就会向调用方返回分布式事务处理失败的结果。

XA-2PC提交协议中会遇到的一些问题：
1）性能问题。从流程上我们可以看得出，其最大缺点就在于它的执行过程中间，节点都处于阻塞状态。
各个操作数据库的节点此时都占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知进行全局提交，参与者进行本地事务提交后才会释放资源。
这样的过程会比较漫长，对性能影响比较大。
2）协调者单点故障问题。事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，会导致参与者收不到提交或回滚的通知，
从而导致参与者节点始终处于事务无法完成的中间状态。
3）丢失消息导致的数据不一致问题。在第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，
另一部分事务参与者没收到提交消息，那么就会导致节点间数据的不一致问题。

2、3PC 也是XA协议的一种。
3PC在2PC提交的基础上增加了CanCommit阶段，并引入了超时机制。
CanCommit阶段的加入:多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的.避免了一些2PC中第一阶段的不必要的数据库资源占用。
超时机制：一旦事务参与者迟迟没有收到协调者的Commit请求，就会在超时后自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。

3、TCC try-commit-cancel
2PC、3PC都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。
TCC分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。



小结：
2PC是数据库事务协议，缺点是：性能问题（长期占用数据库资源）、协调者单点、丢失消息会导致数据不一致。
3PC也是数据库事务协议，3PC相对于2PC的一个提高（相对缓解了2PC中的前两个问题），但是3PC依然没有完全解决数据不一致的问题。缺点是：性能问题（长期占用数据库资源）、协调者单点、丢失消息会导致数据不一致

对比：
            2PC           3PC            TCC
实现原理     DB协议         DB协议         应用层面实现
性能
单点
一致性


2PC、3PC参考：https://blog.csdn.net/bjweimengshu/article/details/86698036
